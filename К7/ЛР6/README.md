Задача 1. Рекурсивно проверить, отсортирован ли список по возрастанию. Важно: без использования sorted().
Бизнес логика: Базовый случай (Выход): Если в списке остался 0 или 1 элемент, значит, список по определению отсортирован. Возвращаем True. Шаг сравнения: Мы берем первый элемент списка и сравниваем его со вторым. Если первый элемент больше второго, порядок нарушен — возвращаем False. Рекурсивный переход: Если первые два элемента стоят правильно, мы "отрезаем" первый элемент и повторяем ту же проверку для оставшейся части списка.
Задача 2. Найти подмассив с максимальным количеством чётных чисел при фиксированном k.
Бизнес логика: Инициализация: Сначала мы считаем количество чётных чисел в самом первом "окне" (первые $k$ элементов списка).Движение окна: Мы начинаем сдвигать окно вправо на один элемент за раз:Уходит старый: Если элемент, который только что покинул окно (слева), был чётным — уменьшаем счётчик.Приходит новый: Если элемент, который только что вошёл в окно (справа), является чётноым — увеличиваем счётчик.Сравнение: На каждом шаге мы проверяем, не стало ли текущее количество чётных чисел больше максимального, что мы видели ранее. Если да — сохраняем индекс начала этого окна.
